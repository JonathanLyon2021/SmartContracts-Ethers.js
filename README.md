# SmartContracts-Ethers.js
This is Exercise 13 in MI4 of Kingsland Universities Blockchain Developer Program.

In this exercise, we will use the ethers.js library to interact with a smart contract deployed on the Ethereum Ropsten <br>
Testnet. We will first compile a contract, deploy it and finally invoke some of the contract’s functions once it’s <br>
deployed.<br>

#### 1. Compiling a Smart Contract <br>
The Smart Contract object is a meta-class, so many of its functions are not defined until it is instantiated with an <br>
Application Binary Interface (ABI) which is usually generated by a compiler, such as the Solidity Compiler. Therefore, <br>
we will use the solc-js library – JavaScript bindings for the Solidity Compiler. <br>
To start, create a new project directory in an appropriate place; open a terminal session and initialize a <br>
package.json file inside the project directory: 

    `npm init -y`
    
After that, install solc-js:

    npm install ––save solc@^0.8.10
    
Because we will be reading a smart contract from a file, we will need a file-system library:

    npm install ––save fs-extra@^0.30.0
    
Last but not least, we need to install ethers.js:

    npm install ––save ethers@5.5.1

After we have installed our dependencies, create a JavaScript file called ethers-workflow.js and require them.

Provider links to a running node in order to connect to the Ethereum blockchain for issuing queries and sending
state changing transactions. It is simply a connection to the network. For the purposes of this exercise, we will use
Ropsten as our provider.
Now, we will create a simple smart contract called ArrayOfFacts.sol which will store an array of strings called facts in
the blockchain. Only the owner of the contract can add facts but anyone should be able to get a count of how many
facts there are and retrieve a specific fact by index.

Now that we have written the smart contract, we will create a function in ethers-workflow.js which reads a file and
returns its content.

Let’s now create a function to compile the smart contract: we will create a function called compileContract which
takes two parameters: the file name and the contract name. It will return an output of the compiled contract.

Now, let’s create an async, self-invoking function to execute the program’s logic.

Let’s save a reference to the ABI for later use.

#### 2. Deploy a Smart Contract <br>
Now that we have compiled our ArrayOfFacts.sol smart contract, it is time to deploy it on the Ropsten Testnet. For
the example of the exercise, we will take one private key from MetaMask and use it to sign the deployment
transaction.

If you do not have ETHt, use the MetaMask faucet: https://faucet.metamask.io/

Page 6 of 17 https://kingslanduniversity.com

Export the private key.

Create a constant to reference the private key copied from Metamask somewhere in ethers-workflow.js

Then create a deployContract function, which takes a Private Key, contract filename and the contract’s name as
parameters.
To deploy a contract to the Ethereum Network, we must have its bytecode and its Application Binary Interface (ABI),
both of which are usually generated by the Solidity Compiler during compilation. Then, we will use the
ethers.ContractFactory(abi, bytecode, wallet) method, which generates the transaction needed to deploy the
contract specified by the bytecode and interface.
Then, using the wallet, we will send the transaction and return the contract.

We receive the info from deploy transaction.

After the transaction is mined our smart contract is finally deployed to the network.
Save a reference to our contract address in ethers-workflow.js.

Now if we go to Ropsten Etherscan and paste the transaction hash and the address of the contract, we should see
an overview of our contract.

#### 3. Playing with the Smart Contract <br>
Now that our smart contract is deployed, we will write to it using ethers to add facts. In order to do this, we will use
ethers.Contract (addressOrName, abi, providerOrSigner) method which connects to the contract address defined
in the ABI. The method also takes a providerOrSigner which may be any instance of a Wallet, Provider or Custom
Signer. For the purposes of this exercise, we will use a Wallet instance.
Create a method called addFact, which takes an contract address, an ABI of the contract, a private key for the wallet
and a fact. The method will return the created transaction.

In the async function call the addFact() function, and comment out deployContract() function, because our contract is
already deployed in the blockchain.

What will happen if someone, different from contract owner, tries to add a fact to the contract? To test this, you
need to call the add method from another address. But in doing so, you must set a high gas limit for the transaction
to pass. This can be done by modifying the addFact function. In this example we set the gas price and the gas limit.

Now, let’s create a method, which calls the contract’s function getFact(uint256 index). Keep in mind that when you
want to GET something from a contract, you do not need a wallet! Therefore, we will just use the provider.

Call getFact in the async function. You can comment the addFact call.

Last but not least, let’s create a function to call the count() method of the contract, which returns the count of the
facts in the contract.

Call the function in the async function.

### Congratulations! You've finsihed the program.
